Redesign of the typechecker,
Monday October 7, in Paris
Minutes of the meeting

### Participants

See the file participants.md,

Gabriel Scherer (GS), François Pottier (FP), Didier Remy (DR), Jacques
Garrigue (JG), Thomas Refis (RF), Xavier Leroy (XL), Leo White (LW), Armaël
Guéneau (AG), Florian Angeletti (FA), Alain Frisch (AF), Nicolás Ojeda Bär
(NOB), Pierrick Couderc PC), Frédéric Bour (FB), Gabriel Radanne (GR),
Damien Doligez (DD), Anil Madhavapeddy (AM).


### Why do we want to do this?

This should be kept in mind while doing the redesign!

# Robustness

# For easier maintenance

# To be more suitable for extensions

- Including immediate extensions in mind: implicits and algebraic effects
- But also future extensions

# More precise specification

- including a reference implementation

# Formalization of the kernel

- On paper, or perhaps in Coq

# Tooling

- Including better support for errors 

# Better performance

- Typechecker is actually slow (for the module system)
- There might be opportunities for optimizations
- Which are hard to do in the current state of the implementation


### Risks

AF: is worried about  backward compatibility, and ask whether this
should be the same language or another language.

DD: there is a continuum between the two extremes: exactly the same language
or another language.

LW: keeping it exactly the same would prevent us from fixing bugs.

Someone mentions getting rid of the object system altogether...

XL: A quote from Guy Steele: when the community wanted to simplify
    JavaScript, they observed that it had already too many users. 

    XL would not like OCaml to turn into JavaScript.

XL thinks that OCaml has too many bug reports. If it were to be redone, some
   features would not be there (e.g. recursive modules) or would have been
   done otherwise. So he supports a clean up during the redesign.

In conclusion, we somehow all wish it to be the next version of the same
language, and not another language, but for the majority it is clear that we
will also do some changes and that it is too early to say which ones.

We discuss the time scale. DR suggests a target of 3 years.  Even though we
understand that it could take longer to make the change more continuous for
users.  AM reminds that for Multicore OCaml it has been 7 years, where most
of the ideas and design was done in the first 3 years. He recommends that we
do not communicate on the redesign of the typechecker in the community, so
as not to create expectations.

### How to work together

# GitHub

LW proposes to use git for everything in the model of RFC (see for example
the discussed on unboxed types), where a proposal can be described and
commented.

For more research-like topics, we could also open sub-directories and push
drafts of the research project and updates them at significant steps.

There is an agreement that GitHub is a good tool to keep each other informed
of the actions going on and of their progress. 

We should do this in a private branch, since we do not want to communicate
publicly on the redesign of the typechecker...

# Meetings

How often should we plan meetings? This is unclear: we are probably going to
work and perhaps meet in small groups around specific precise tasks. Hence,
we would not need to meet altogether too often, perhaps twice a year to keep
us informed of the advances of the different projects.

We could also use video conf, especially for some small group meetings.

We should plan meeting more longer ahead (2 months) to make it easier to
find a slot that is convenient for almost all of us.  We are invited to host
one of the meetings in London. 


### Typed Intermediate Language

We all agree on the need for a Surface Typed Intermediate Language (S-TIL)
that is closed to the Source language and the output of type inference.

There should also be a smaller Kernel Typed Intermediate Language, but it
is unclear at this point what how far from the surface it should be:

 - It should at least remove all syntactic sugar.

 - But it should not complicate the type system just for the sake of
   reducing the size of kernel.

We should be aware of over previous experiments that ended up in using Coq
as the internal language to be able to encode everything else (cf. Zhong
Shao).  Is this what we want? He encourages us to look at previous works.

JG mentions that perhaps a compilation to Coq could be used
as a way to prove type soundness. 

Xavier wants to avoid type preserving compilation, which is difficult---even
for inlining it's not easy. 

The goal of having a Typed Intermediate Language is not for compiling but
for having a smaller language to formalize (soundness proof).  We may then
remove types (or move to simpler types) for the rest of the compilation.


### High-level roadmap

This describes the informal discussion we had before lunch, See the list of
high-level tasks below that we agreed on after lunch.

This discussion was a little disorganized and is difficult to summarize.
The main points are the following.

# Concurrency (later called synchronization)

- Inference will have to be "concurrent" for implicits, because of the
  interaction between the core level and the module level.
  Just for HO unification, ie. pattern unification, this is the way it
  works. 

- FP reminds that the constraints will need a clear specification.

- Type inference is also needed for disambiguation

- It is unclear that we could separate constraint generation and constraint
  resolution, because of name disambiguation.

# principal mode?

- In OCaml, type inference is not principal, even in principal mode!
  It is only maximal, i.e. the typechecker never take an arbitrary step.

- There is a form of "local type inference" (e.g. for labeled arguments)

# GADTs

- Nested patterns with GADTs are quite tricky.  (Later, at lunch, we could
  not even agree on whether compiling GADT with nested patterns
  into flat patterns would preserve well-typedness)

# Difficult parts are 

- sharing

- propagation of annotations/types



### High-level tasks 

# S-TIL (Surface Typed Intermediate Language)

Participants: DR, JG, TR.

==> Looking for a leader

(We forgot to come back at this task at the end of the discussion...) 

- One argument was whether we could define S-TIL now or have to wait for
  advances on other tasks... 


# Sharing

Participants: DR (leading), DP, GR, JG, LW

- This refers to all forms of sharing in types: type abbreviations, sharing
  for object types, sharing for polytypes, type equalities for module
  types. 

- Subtopics are: principality, polytypes.


# Synchronization

Participants: DR (leading), DP, GR, JG, LW, GS (name resolution)

- This refers to the propagation of information learned during type
  inference: propagation of source type annotations, but also using the type
  inferred for a function to help type the arguments or propagate the type a
  a let-binding as we would propagate its type annotation if it had one.

- This will introduce a form of synchronization during constraint solving.

- We also need to treat constraints concurrently, to solve them in an order
  that cannot be determined in advance.

- Subtopics are also: principality, polytypes.

- Name resolution should fit there as well.


# Integration between Core & Module languages

Participants: GR (leading), DR, JG, LW (type inference only)

Two subtopics that can be looked at separately are

 - type inference
 
 - type checking


# Tooling & Incrementality

Participants: GR (leading), FB, TR, FA, FP, DR, GS

- Type errors

- Keeping enough information in the S-TIL for better tooling

- A lot of engineering here

  + Isolating the sate of the typechecker (i.e. we should be able to run
     multiple instances of the typechecker)
     
  + toplevel interface
  
  + loading of global modules

  + debugging tools


# Rows, Subtyping & Effects: LW (leading), DR, FP, JG


# GADTs: JG (leading), DR, FP


# Labeled arguments: JG (leading), DR, LW


# Classes & Objects: JG, LW, DR

==> Who is leading? JG? 

# Kind system: DR, FP, GR, LW, SD

- Including subkinding

==> Who is leading? 
