Gabriel: my main proposal is, for the "rebuild the type-checker from
scratch" part, to create a repository on top of Inferno¹ that
implements a ML language (MidML, MoyenML?). We start from the nano-ML
example used in Inferno itself (as a typical example of Inferno client
program). We add important features from the OCaml type system, one
after the other, which requires adding new features to Inferno
itself -- as clear and general as possible to express the desired ML
type-inference features. This is useful to get a clean theory (of the
ML feature, of the inference support for it), looking at interactions
with other features, with a reference implementation that keeps
growing. And for some of those features we can publish papers.

The notes below include at the end a list of features to which we
could think of during the discussion -- a decomposition of OCaml's
type system in smaller.

¹ Inferno is François Pottier's type-inference library. I (Gabriel)
would recommend reading its implementation -- I did it from the
high-level layers to the low-level layers. It is hosted on François's
favorite open-source closed-development platform:
https://gitlab.inria.fr/fpottier/inferno .

----

# Global approach

We should do "incremental" and "from scratch" ("big bang") in
parallel, with communication between both.


Incrémental

- Start from the TODO list and Thomas' and Leo's ideas

  Jacques: I'm less interested in that part.

  Gabriel: but we will ask you to review what people have done.

  Jacques: I was mostly speaking of the refactoring. Conceptual
  changes (like adding scopes) are more interesting to me.

  Gabriel: I think sometimes conceptual changes emerge
  from refactoring, when done carefully.


Big-bang

- Use Inferno + MoyenML as an experimental vehicle to study the essence
  of OCaml type-system features, layer by layer.

  How to bridge the gap between MoyenML-gone-big and OCaml? One
  possibly, if required (it's not pretty), would be to replace the
  lowest layers of Inferno (Union-Find, levels/generalization etc.) by
  the OCaml type representation and its manipulation code
  (atype/btype/ctype).

  (Didier: the interface of Inferno is nice, but in the implementation
  I'm not convinced by the very-effectful approach of François. Maybe
  we don't want that on the long term, it may not scale to more
  advanced constraints.)

Core language: what's an explicitly-typed representation that the
OCaml type-inference engine could produce as result?

  Jacques: about that, I was thinking of using CIC (Calculus of
  Inductive Constructions), to represent the values of OCaml's
  intermediate representation with dependent types. -- use Gallina as
  intermediate representation.


## Feature map to add to Inferno + MidML

### Term language

- [data]: algebraic datatypes
  + pattern-matching

- type abbreviations

- label overloading (constructors and fields)
  (depends on [data])

  Gabriel: http://gallium.inria.fr/~scherer/topics/delayed-constraints-for-disambiguation.txt

- scoped type variables

- first-class polymorphism

- GADTs
  (depends on [data])

- structural rows
  (objects, polymorphic variants)

- checking .mli
  (the inclusion check between type declarations)

- value restriction?
  + partial generalization
  + relaxed value restriction (variance)

### Error report (entry later added by DR)

- minimal error report needed

- explore other solutions
  + Nathanael proposal: report unification errors in terms of typing
    constraints from the soruce. 

### Propagation of source typing annotations (later added by DR)

- Preprocessing step?

- During constraint generation?

- Other: new form of constraints? 

### Modules

- modules
- first-class modules

